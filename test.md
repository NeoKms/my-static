
# План проекта: Платформа публикации статей на NestJS + Vue 3

## Общие требования
- Backend на NestJS с TypeScript  
- База данных: PostgreSQL через TypeORM  
- Redis для кэширования и blacklist токенов  
- RabbitMQ через golevelup (без декораторов)  
- WebSocket для комментариев  
- Загрузка файлов локально  
- Leaflet для карт  
- Frontend — отдельный проект на Vue 3 без Nuxt 
- Pinia для управления состоянием во фронтенде
- Swagger для документации API  
- Взаимодействие frontend и backend через REST API + WebSocket  


## Используемые технологии и библиотеки

| Задача               | Технология/библиотека        |
|----------------------|------------------------------|
| Backend Framework    | NestJS                       |
| ORM                  | TypeORM                      |
| База данных          | PostgreSQL                   |
| Кэширование          | Redis (через ioredis)        |
| Очереди              | RabbitMQ (golevelup пакет)   |
| WebSocket            | NestJS WebSocket Gateway     |
| Файлы                | Multer                      |
| Документация API     | Swagger                      |
| Frontend Framework   | Vue 3                        |
| State Management     | Pinia                       |
| HTTP Client          | Axios                       |
| Карты                | Leaflet                     |

---

## Структура этапов

### Этап 1: Инициализация проектов  
**Backend**  
- Создание NestJS проекта через CLI (`nest new`)  
- Настройка TypeScript, ESLint, Prettier  
- Подключение ConfigModule для работы с `.env` и его типизация

**Frontend**  
- Создание Vue 3 проекта (`create-vue`)  
- Подключение vue-router и pinia  
- Создание базовых страниц: /login, /register, /articles, /article/:id (пустые, но в использованием роутера)

*Цель*: запустить два проекта, понять структуру и взаимодействие.

---

### Этап 2: Настройка базы и TypeORM  
**Backend**  
- Подключение PostgreSQL  
- Настройка TypeORM в NestJS  
- Создание сущностей User и Article  
- Реализация базового репозитория и сервиса для User  

**Frontend**  
- Настройка axios и конфигурация API URL через `.env`  
- Создание api.ts и userStore в pinia  
- Создание форм логина и регистрации  

*Цель*: установить реальную связь фронтенда с бэкендом через API.

---

### Этап 3: Аутентификация (JWT + cookie + Redis)  
**Backend**  
- Регистрация и логин с хешированием паролей  
- Выдача JWT, сохранение в HttpOnly cookie  
- Logout с сохранением токенов в blacklist (Redis)  
- Защищенный endpoint /me  

**Frontend**  
- Отправка форм, сохранение сессии через cookie  
- Получение текущего пользователя с /me  
- Управление состоянием пользователя в authStore (pinia)  

*Цель*: показать реальную работу авторизации и интеграцию.

---

### Этап 4: Swagger-документация  
**Backend**  
- Подключение Swagger модуля  
- Создание DTO и валидация с class-validator  
- Документирование API с примерами  

*Цель*: облегчить тестирование API.

---

### Этап 5: CRUD статей  
**Backend**  
- Реализация создания, редактирования, удаления и получения статьи  
- Привязка статьи к пользователю-автору  

**Frontend**  
- Форма создания и редактирования статьи  
- Отображение списка статей и переход к статье  

*Цель*: полноценная работа с сущностью статьи.

---

### Этап 6: Загрузка файлов (изображения)  
**Backend**  
- Использование Multer для загрузки файлов локально  
- Эндпоинт загрузки с возвратом URL  

**Frontend**  
- Компонент для загрузки файлов  
- Подстановка загруженных файлов в статьи  

*Цель*: практика работы с медиа.

---

### Этап 7: Комментарии + WebSocket  
**Backend**  
- Создание сущности комментария  
- Реализация WebSocket gateway для комментариев  
- Эмит сообщений в канал статьи  

**Frontend**  
- Компонент комментариев с подпиской на WebSocket  
- Отправка новых комментариев  

*Цель*: добавить realtime-обновления.

---

### Этап 8: Глобальный поток комментариев через RabbitMQ  
**Backend**  
- Интеграция golevelup/nestjs-rabbitmq без декораторов  
- Публикация комментариев в exchange  
- Подписка WebSocket шлюза на очередь RabbitMQ  

*Цель*: демонстрация очередей и разделения продюсеров/консьюмеров.

---

### Этап 9: Кэширование через Redis  
**Backend**  
- Реализация RedisService на ioredis  
- Кэширование списков и отдельных статей  
- Инвалидация кэша при изменении данных  

*Цель*: оптимизация производительности.

---

### Этап 10: Карта (Leaflet) и геометки  
**Backend**  
- Добавление координат к сущности статьи  

**Frontend**  
- Использование Leaflet для отображения геометок  
- Форма выбора координат  

*Цель*: работа с геоданными.

---

### Этап 11: Поиск и фильтрация  
**Backend**  
- Реализация фильтров по авторам, тегам, ключевым словам  

**Frontend**  
- Интерфейс поиска и фильтрации  

*Цель*: улучшение UX.

---

### Этап 12: Docker и деплой (опционально)  
- Создание Dockerfile для backend и frontend  
- Настройка docker-compose с PostgreSQL, Redis, RabbitMQ  
- Инструкции по запуску  

---
